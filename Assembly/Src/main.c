/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f407xx.h"
//#define SYSTICK
//#define ACESS_LEVEL_CHANGE
#define STACK_CHANGE

#if defined (ACESS_LEVEL_CHANGE)

void SVC_Handler(void) {
    __asm volatile (
        "MOV R0, #0\n"        // Load 0 into r0 (privileged access level)
        "MSR CONTROL, R0\n"   // Move the value in r0 to the CONTROL register
        "ISB"                 // Instruction Synchronization Barrier
    );
}

void set_unprivileged_mode(void) {
    __asm volatile (
        "MOV R0, #1\n"        // Load 1 into r0 (unprivileged access level)
        "MSR CONTROL, R0\n"   // Move the value in r0 to the CONTROL register
        "ISB"                 // Instruction Synchronization Barrier
    );
}

void set_privileged_mode(void) {
    __asm volatile (
        "SVC 0"  // Trigger the SVC exception to switch back to privileged mode
    );
}

int main(void) {
    set_unprivileged_mode();  // Switch to unprivileged mode

    // Code running in unprivileged mode

    set_privileged_mode();    // Return to privileged mode using SVC call

    while (1) {
        // Main loop
    }
}

#elif defined (STACK_CHANGE)

void set_psp(uint32_t stack_addr) {
    __asm volatile (
        "MSR PSP, %0\n"       // Set PSP to the given address
        "ISB"                 // Instruction Synchronization Barrier
        :                      // No output
        : "r" (stack_addr)    // Input: stack address
    );
}

void switch_to_psp(void) {
    __asm volatile (
        "MOV R0, #2\n"        // Load 2 into R0 (sets bit 1 to select PSP)
        "MSR CONTROL, R0\n"   // Move the value in R0 to the CONTROL register
        "ISB"                 // Instruction Synchronization Barrier
    );
}

void switch_to_msp(void) {
    __asm volatile (
        "MOV R0, #0\n"        // Load 0 into R0 (clears bit 1 to select MSP)
        "MSR CONTROL, R0\n"   // Move the value in R0 to the CONTROL register
        "ISB"                 // Instruction Synchronization Barrier
    );
}

int main(void) {
    uint32_t process_stack[128];  // Define a stack area for PSP

    // Set the Process Stack Pointer to the top of the process stack
    set_psp((uint32_t)&process_stack[127]);  // PSP points to the top of the stack (full descending stack)

    switch_to_psp();  // Switch to PSP

    // Code running with PSP

    switch_to_msp();  // Switch back to MSP

    while (1) {
        // Main loop
    }
}



#else SYSTICK

// Function prototype for SysTick handler
void SysTick_Handler(void);

int main(void) {
	// Enable the clock for GPIO Port D
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;  // Enable GPIO Port D clock

	// Configure PD13 as Output
	GPIOD->MODER &= ~(0x3 << (13 * 2));      // Clear mode bits for PD13
	GPIOD->MODER |= (0x1 << (13 * 2));       // Set PD13 to Output mode

	// Set up SysTick timer
	SysTick->LOAD = 16000000 - 1; // Load the timer for 1 second at 16 MHz clock
	SysTick->VAL = 0;              // Clear the current value register
    SysTick->CTRL = 0x07;         // Enable SysTick, use processor clock, enable interrupt

    // Enable NVIC for SysTick interrupt
    NVIC_SetPriority(SysTick_IRQn, 1); // Set the priority (optional)
    NVIC_EnableIRQ(SysTick_IRQn);       // Enable the SysTick interrupt in the NVIC


//	__asm__ (
//			"MOV R2, #10\n"      // Load 10 into R2
//			"MOV R3, #7\n"// Load 7 into R3
//			"ADD R4, R2, R3\n"// Add R2 and R3, store result in R4
//	);

	while (1) {

	}
}

// SysTick interrupt handler
void SysTick_Handler(void) {
	// Inline assembly to toggle PD13 (LED)
	__asm__ (
			"LDR R0, =0x40020C14\n"  // Load address of GPIOD ODR
			"LDR R1, [R0]\n"// Load the current ODR value into R1
			"EOR R1, R1, #0x2000\n"// Toggle bit 13 (PD13) in R1
			"STR R1, [R0]\n"// Store the new value back to ODR
	);
}
#endif
